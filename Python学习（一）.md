

# Python 学习（一）

### 1. 数据结构与循环

#### 1.1 列表（List）：

列表的声明方式：其中 [] 可以是一个空列表：

~~~python
my_first_list = [1,2,4,8,16]
~~~

列表的访问方式：列表使用索引访问其中元素，其中第一个元素索引是0，最后一个元素索引是 length-1

~~~python
print(my_first_list[1])
~~~

也可以从末尾对列表进行索引，最后一个元素位于 -1 位：

~~~python
print(my_first_list[-1])
~~~

输出列表的切片 [start : end] ，输出从索引 start 开始，到 end 前一个为止：

~~~python
print(my_first_list[1:4])
~~~

输出：[2,4,8]

切片方式2 [start : ]，输出从索引 start 开始，到列表最后一个为止：

~~~python
print(my_first_list[1:])
~~~

输出：[2,4,8,16]

切片方式3 [ : end]，输出从索引 0 开始，到 end 前一个为止：

~~~python
print(my_first_list[:4])
~~~

输出：[1,2,4,8]



列表的函数：

max(list)：此函数用于报告列表中的最大元素：

~~~python
max(my_first_list)
~~~

min(list)：此函数用于报告列表中最小元素：

~~~python
min(my_first_list)
~~~

sorted(list)：此函数返回函数的排序副本：

~~~python
sorted(my_first_list)
~~~

返回逆向排序的副本：

~~~python
sorted(my_first_list,reverse=True)
~~~

list.append(element)：在列尾处添加元素：

~~~python
my_first_list.append(32);
print(my_first_list);
~~~

list.insert(index,element)：在列表指定的索引处插入元素，索引原元素直到末尾的元素均向后移动一位：

~~~python
my_first_list.insert(2,74);
print(my_first_list);
~~~

输出：[1,2,74,4,8,16]

list.clear()：删除列表中所有元素：

~~~python
my_first_list.clear();
~~~

list.count(element)：元素在列表中出现的次数：

~~~python
my_first_list.count(4)
~~~

list.remove(element)：从列表中移除元素，如果列表中不存在该元素，则抛出错误：

~~~python
my_first_list.remove(4)
~~~

list.reverse()：将列表在原列表内逆序：

~~~python
my_first_list.reverse()
~~~

list.pop()：从列表中移除最后一个元素：

~~~python
my_first_list.pop()
~~~



for循环：

~~~python
for i in range(1,100):
    print(i)
~~~

(1) for 是 python 中的一个关键字，用于声明 for 循环

(2) for 之后是迭代的条件，i 在 1~100 范围内迭代

(3) 在迭代表达式后是一个冒号

(4) 循环的主体，由4个空格，或制表符缩进



while循环：

~~~python
i = 1
while i<5:
    print(i*i)
    i=i+1
~~~

(1) 关键字 while 用来声明 while 循环

(2) 控制循环的条件（i<5），如果条件为真，则循环保持运行

(3) 冒号位于条件之后



#### 1.2 set 集合：

Python 中的集合是无序的唯一元素的集合：

~~~python
my_duplicate_list = [1,2,3,1,2,3,5,6,3,2]
print(my_duplicate_list)
my_unique_list = set(my_duplicate_list)
print(my_unique_list)
~~~



#### 1.3 字典

字典（Dictionary）是 Python 中的键值对，键值被存储在索引中：

~~~python
dictionary = {'A':1,'B':2,'C':3}
~~~

可以使用键来访问字典元素：

~~~python
dictionary['A']
~~~

还可以通过使用键来改变字典元素的值：

~~~python
dictionary['A'] = 5
~~~

通过键来迭代字典：

~~~python
for key in dictionary:
    print(key,dictionary[key])
~~~

创建字典嵌套字典：

~~~python
complex_dict = {'first_dict':{'A':1,'B':2,'C':3},'second_dict':{'E':4,'F':5,'G':6}}
~~~



#### 1.3 元组 

元组（Tuple）是有序的元素集合，元组和列表的不同之处在于元组是不可变的，但列表不是，一旦赋值，就不能插入或删除元组中的值。

~~~python
dim = (45.23,67,34)
~~~



### 2. Python 操作文件

文件用于在磁盘中存储数据，它可以是任何形式，如文本，CSV，图像，音频，视频等。

可以使用 read() 函数来读取文件。首先，需要在读取模式下打开文件：

~~~python
f = open('PathTo/my_file','r')
file_content = f.read()
~~~

读取文件之后，可以通过 close() 函数关闭：

~~~python
f.close()
~~~

使用 write() 函数完成文件编写，需要在写入的模式下打开文件，然后再执行写入操作并关闭文件：

~~~python
f = open('PathTo/my_file','w')
f.write('Writing in File')
f.close()
~~~

使用 with 关键字可以读取或写入文件：

~~~python
with open('PathTo/my_file)','r') as f:
    print(f.read())
~~~

执行完操作后，文件自动关闭。



### 3. 特征工程

特征工程是从数据中对特征进行工程化（如创建，转换等）的过程。

#### 3.1 什么是特征

以存储在 SQL 数据库表中的数据为例，表由行和列组成，表中包含整型数据，字符串数据，日期字段等。现在我们想要对日期列进行一些分析，但是它并没有直接的应用价值。所以，先编写一个程序来提取任意特定的日期，并创建带有该信息的单独列。现在，所有的日期（星期一，星期二等）被归为一列，然后，创建一个脚本来检查某一天是周末还是工作日。创建另一个字段 is_weekend ，如果那天是周末，则其为True；否则为False。

通过日期和 is_weekend两个列构成的数据，我们可以分析或建立预测模型，这就是特征。

在数据科学过程中有效地属性（或字段）被称为特征，特征的选取可能取决于需求的类型。在上述例子中，我们对周末信息更为感兴趣，而其它的分析可能需要通过一周中的某一天或一年中的某一个月来进行。在这种情况下，一年中的月份就是特征。

> 根据需求，抽取待分析对象的有效特征。一个特征作为所有记录的共同属性，将它们聚集成一列，然后设置另外的字段，作为分析这个特征的依据。

特征的主要应用方面有：

(1) 计算机视觉技术中：如图像像素，边缘，角点等。

(2) 语音识别，如声音，噪音等。

#### 3.2 为什么执行特征工程

在机器学习中，任何建模技术想要获得满意的结果都需要良好的数据特征。特征对于提高模型的预测能力而言十分重要，当尝试解决现实问题是，由于特征可能存在许多问题，如缺失值，离群值，不同类型，数据收集错误等，因此并不总是能获取到理想的特征。在使用特征数据训练机器学习模型时，必须先对特征进行清理，变换并找到正确地特征集。

在特征工程中花费时间是有一定好处的：

(1) 使简单模型的执行效果比复杂模型好；

(2) 减少模型选择时间，增加了简单模型的预测能力；

(3) 通过简化模型来缩短训练时间。



#### 3.3 特征提取

特征提取是对现有的特征集进行一些变换，来选择新特征以取出冗余的过程。新特征可以像旧特征一样准确地表示数据。



#### 3.4 特征的处理方法

根据特征的种类不同，我们可以通过遵循一些基本原则来处理它们：

(1) 数值特征：

最大最小标准化：这个过程使得特征的范围在 [0,1] 内。首先计算每个数值特征的最大最小值，然后对每个特征进行如下变换：

![1633069887041](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1633069887041.png)

Z-分数标准化：

(2) 文本特征：

创建单词计数向量：



### 4. 监督学习

在监督学习中，我们得到了一个数据集，并且已**经知道我们的正确输出**应该是怎么样子，并且**知道输入和输出之间存在关系**。

监督学习问题分为 **“回归”** 和 **“分类”** 问题，在回归问题中，我们试图预测连续输出中的结果，这意味着我们试图将**输入变量映射到某个连续函数**。在分类问题中，我们试图在离散输出中预测结果，这意味着我们试图将**输入变量映射到离散类别**中。

示例 1：

给定有关房地产市场上房屋大小的数据，尝试预测它们的价格。价格作为规模的函数是一个连续的输出，所以这是一个回归问题。

![1633065713946](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1633065713946.png)

​									房价预测的回归模型

在监督学习中，我们已经给出了一些数据以及它们对应的输出，要通过回归曲线来预测任意符合输入要求的连续输入的输出。

我们也可以将这个问题转化为一个分类问题，当我们将输出变为 “售价高于还是低于要价” ，这里，我们根据价格将房屋分为两个独立的类别。

示例 2：

(a) 回归——给定一张人的照片，我们必须根据照片预测他们的年龄。

(b) 分类——给定一个患有肿瘤的患者，我们必须预测肿瘤是恶性的还是良性的。

![1633065902944](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1633065902944.png)

​						（分类）预测肿瘤是良性还是恶性

![1633066032573](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1633066032573.png)

​						根据肿瘤大小将肿瘤分为良性和恶性





### 5. 无监督学习

无监督学习使我们能够在**几乎不知道结果**应该是什么样子的情况下解决问题。我们可以**在数据中推导出结构**，而我们不一定知道变量的影响。

我们可以通过**基于数据中变量之间的关系对数据进行聚类分析**来推导出这种结构。

对于无监督学习，没有基于预测结构的反馈。



在监督学习中，每个给出数据集中的例子都有已经被告知的正确答案，如下每个例子都被指明了正确和错误：

![1633066416536](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1633066416536.png)

​					该数据集中的数据被分为正确和错误两种



而在非监督学习中，我们所给出的数据都是没有任何标签的，我们只是被告知，它们是一个数据集，以及能否从中找到一些结构：

![1633066540037](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1633066540037.png)

​									该数据集被分为两个集群



示例：

聚类：收集 1,000,000 个不同的基因，并找到一种方法将这些基因自动分组到不同的变量（如寿命，位置，角色等）之间，这些基因某种程度上相似或相关。

![1633067006238](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1633067006238.png)

这是一群不同个体的基因序列，对于他们之中的每一个个体，我们可以通过技术手段测量它们有多少或者有没有某个基因。但是我们没有他们的详细信息，所以可以根据测量这些基因的表达情况，通过运行聚类算法，从而将他们分为不同的类型，或者分入不同类型的人中。



非聚类：“鸡尾酒会算法”，可让你在混乱的环境中找到结构。（即从鸡尾酒会上的声音网中识别个人声音和音乐）。

在一个鸡尾酒会上，如果两个人同时使用麦克风说话，而这些麦克风的声音相同，当两个麦克风同时发出声音时，会导致他们的声音组合在一起。我们可以分别拿这两个麦克风的声音给一个叫做 “鸡尾酒会算法” 的无监督学习算法，并告诉算法，请在数据中心找到结构。



### 6. 模型和成本函数

#### 6.1 模型表示

为了建立符号以备将来使用，我们使用 X(i) 表示 “输入” 变量，也称为输入特征，用 y(i) 表示我们试图预测的 “输出” 或目标价格。一组( x(i) 和 y(i) )被称为训练示例，我们用来进行学习的数据集是m个训练示例的一个列表。其中 (i) 是训练集的索引。

在监督学习问题中，我们的目标是：给定一个训练集，用来学习一个函数 h : X -> Y，使得训练过后 h(x) 是对应 y 值得一个 “好” 预测器。这个函数 h 也被称为 “假设函数”。

训练过程如下：

![1633069073043](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1633069073043.png)



当我们试图预测的目标变量是连续的时，我们将学习问题称为回归问题；当 y 只能采用少量离散值时，我们称其为分类问题。

#### 6.2 成本函数

我们可以使用成本函数来衡量假设函数的准确性。这需要假设的所有结果与来自 x 的输入和实际输出 y 的平均差异：

![1633069382206](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1633069382206.png)

这个函数叫做 “均方误差” 。平均值减半是为了方便计算梯度下降





### 7. 数据可视化

Python 中常用的可视化数据有 Matplotlib，Seaborn，ggplot，Geoplotlib，Bokeh，Plotly等。以下主要使用 Matplotlib 可视化数据包。

#### 7.1 折线图

